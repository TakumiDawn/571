[
["13-a-brief-introduction-to-time-series.html", "Chapter 13 A Brief Introduction to Time Series 13.1 Trend + Seasonality 13.2 Correlated Error Models", " Chapter 13 A Brief Introduction to Time Series # Usual library loading stuff library(multcomp); library(multcompView) library(lsmeans) library(MASS) library(faraway) library(ggplot2) library(dplyr) library(lubridate) 13.1 Trend + Seasonality Often we just want a way to model trends on two (or more) time scales. Consider the CO2 data from data(co2) CO2 &lt;- data.frame( value = as.vector(co2), year = rep(1959:1997, each=12), month = rep(1:12, times=39)) CO2 &lt;- CO2 %&gt;% mutate( time = ymd(paste(year, month, 1)) ) ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) # Zoom in on a couple of years ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) + scale_x_datetime(limits=ymd(&#39;1980-1-1&#39;, &#39;1982-12-31&#39;)) ## Warning: Removed 432 rows containing missing values (geom_point). So how do we fit the seasonal trend? We want a curve that looks something like a combination of these: x &lt;- seq(0, 2*pi, by=.01) foo &lt;- rbind( data.frame(curve=&#39;sine&#39;, x=x) %&gt;% mutate(y=sin(x)), data.frame(curve=&#39;cosine&#39;, x=x) %&gt;% mutate(y=cos(x))) ggplot(foo, aes(x=x, y=y, color=curve)) + geom_line() But I also want to be able to have the curve span across the months, not just from 0 to \\(2*\\pi=6.28\\) So lets add a term for the fact that we want these to run from 0 to 12. w &lt;- 12 x &lt;- seq(0, w, by=.01); foo &lt;- rbind( data.frame(curve=&#39;sine&#39;, x=x) %&gt;% mutate(y=sin(2*pi*x/w)), data.frame(curve=&#39;cosine&#39;, x=x) %&gt;% mutate(y=cos(2*pi*x/w))) ggplot(foo, aes(x=x, y=y, color=curve)) + geom_line() So we think that \\[\\cos\\left(2\\pi* \\frac{x}{\\omega}\\right)\\] and \\[\\sin\\left(2\\pi * \\frac{x}{\\omega}\\right)\\] would be a useful set of functions for modeling this seasonal trend. But these functions are just transformations of \\(x\\) just as \\(x^2\\) and \\(x^3\\) were. So lets just do another transformation. model &lt;- lm( value ~ year + sin(2*pi*month/12) + cos(2*pi*month/12), data=CO2) CO2 &lt;- CO2 %&gt;% mutate( fit = predict(model) ) ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) + #scale_x_datetime(limits=ymd(&#39;1980-1-1&#39;, &#39;1982-12-31&#39;)) + geom_line(aes(y=fit), color=&#39;red&#39;) This isn’t too bad, but the long term trend is off. Lets add a squared term onto the year. model &lt;- lm( value ~ poly(year, 2) + sin(2*pi*month/12) + cos(2*pi*month/12), data=CO2) CO2 &lt;- CO2 %&gt;% mutate( fit = predict(model) ) ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) + #scale_x_datetime(limits=ymd(&#39;1980-1-1&#39;, &#39;1982-12-31&#39;)) + geom_line(aes(y=fit), color=&#39;red&#39;) That fits the long term trend better, now lets zoom in on just a couple of years: ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) + scale_x_datetime(limits=ymd(&#39;1980-1-1&#39;, &#39;1982-12-31&#39;)) + geom_line(aes(y=fit), color=&#39;red&#39;) ## Warning: Removed 432 rows containing missing values (geom_point). ## Warning: Removed 432 rows containing missing values (geom_path). We are missing the troughs a bit. Almost like my model isn’t quite flexible enough. So just as we added more powers for the polynomials \\(x^3, x^4, \\dots\\) we can add flexibility to these by adding higher frequency sine and cosine curves. w &lt;- 12 x &lt;- seq(0, w, by=.01); foo &lt;- rbind( data.frame(curve= &#39;sine&#39; , x=x) %&gt;% mutate(y=sin(2*pi*x/w)), data.frame(curve=&#39;cosine&#39; , x=x) %&gt;% mutate(y=cos(2*pi*x/w)), data.frame(curve= &#39;sine2&#39;, x=x) %&gt;% mutate(y=sin(2*pi*x/w*2)), data.frame(curve=&#39;cosine2&#39;, x=x) %&gt;% mutate(y=cos(2*pi*x/w*2)) ) ggplot(foo, aes(x=x, y=y, color=curve)) + geom_line() Now we fit a model with a with a polynomial that describes the long-term trends and a bunch of functions of sine and cosine that models the with-in year seasonality. model &lt;- lm( value ~ poly(year,2) + sin(2*pi*month/12) + cos(2*pi*month/12) + sin(2*pi*month/12 * 2) + cos(2*pi*month/12 * 2), data=CO2) CO2 &lt;- CO2 %&gt;% mutate( fit = predict(model) ) # Zoom in on a couple of years ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) + scale_x_datetime(limits=ymd(&#39;1980-1-1&#39;, &#39;1982-12-31&#39;)) + geom_line(aes(y=fit), color=&#39;red&#39;) ## Warning: Removed 432 rows containing missing values (geom_point). ## Warning: Removed 432 rows containing missing values (geom_path). The sine and cosine bits are part of something that generalizes curve fitting to allow very flexible types of curves. For time-series the sine and cosine family of basis functions is quite handy but require a bunch of technical fiddling to just use as we have done here. Most of the packages that we might use while doing time-series analysis will allow you just specify to fit a smooth curve to the Months. library(mgcv) ## Warning: package &#39;mgcv&#39; was built under R version 3.2.4 ## Loading required package: nlme ## Warning: package &#39;nlme&#39; was built under R version 3.2.4 ## ## Attaching package: &#39;nlme&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## collapse ## This is mgcv 1.8-12. For overview type &#39;help(&quot;mgcv-package&quot;)&#39;. # I am cheating a bit because I&#39;m using a different # set of basis functions. See STA 578 for more info... model &lt;- gam(value ~ s(year) + s(month, bs=&#39;cc&#39;), data=CO2) CO2 &lt;- CO2 %&gt;% mutate( fit = predict(model), resid = resid(model)) ggplot(CO2, aes(x=time, y=value)) + geom_point() + ggtitle(&#39;Mauna Loa Atmospheric CO2&#39;) + geom_line(aes(y=fit), color=&#39;red&#39;) 13.2 Correlated Error Models ggplot(CO2, aes(x=time, y=resid)) + geom_line() + geom_point() + geom_hline(yintercept = 0, color=&#39;red&#39;) There are streches where the residuals are consistently positve or negative for many months in a row. Which should be very rare if the error terms are independent. 13.2.1 White Noise Z &lt;- rnorm(100) df &lt;- data.frame(t = 1:length(Z), Z=Z) ggplot( df, aes(x=t, y=Z)) + geom_point() + geom_line() + geom_hline(yintercept = 0, color=&#39;red&#39;) Here we have some runs of positive and negative, but what does the autocorrelation function look like? acf( Z ) 13.2.2 Random Walk Process \\[X_t = X_{t-1} + Z_t\\] Notice that because we need a starting point X &lt;- NULL X[1] &lt;- Z[1] # first one doesn&#39;t have a preceding for( t in 2:100 ){ X[t] &lt;- X[t-1] + Z[t] } df &lt;- data.frame(t = 1:length(X), X=X) ggplot( df, aes(x=t, y=X)) + geom_point() + geom_line() + geom_hline(yintercept = 0, color=&#39;red&#39;) acf(X) 13.2.3 Moving Average Process We will consider an MA(q=2) process. X &lt;- NULL beta &lt;- c(.4, .1) X[1] &lt;- Z[1] X[2] &lt;- Z[2] + Z[1]*beta[1] X[3] &lt;- Z[3] + Z[2]*beta[1] + Z[3]*beta[2] for( t in 4:100 ){ X[t] &lt;- Z[t] + Z[t-1]*beta[1] + Z[t-2]*beta[2] } df &lt;- data.frame(t = 1:length(X), X=X) ggplot( df, aes(x=t, y=X)) + geom_point() + geom_line() + geom_hline(yintercept = 0, color=&#39;red&#39;) acf(X) 13.2.4 Autoregressive Processes # AR(p=2) process X &lt;- NULL alpha &lt;- c(.5, .1) X[1] &lt;- Z[1] X[2] &lt;- X[1]*alpha[1] + Z[2] X[3] &lt;- X[2]*alpha[1] + X[1]*alpha[2] + Z[3] for( t in 4:100 ){ X[t] &lt;- X[t-1]*alpha[1] + X[t-2]*alpha[2] + Z[t] } df &lt;- data.frame(t = 1:length(X), X=X) ggplot( df, aes(x=t, y=X)) + geom_point() + geom_line() + geom_hline(yintercept = 0, color=&#39;red&#39;) acf(X) # AR(p=1) process X &lt;- NULL alpha &lt;- c(.2) X[1] &lt;- Z[1] X[2] &lt;- X[1]*alpha[1] + Z[2] for( t in 3:100 ){ X[t] &lt;- X[t-1]*alpha[1] + Z[t] } df &lt;- data.frame(t = 1:length(X), X=X) ggplot( df, aes(x=t, y=X)) + geom_point() + geom_line() + geom_hline(yintercept = 0, color=&#39;red&#39;) acf(X) "]
]
